# Задание 1
Скрипт мониторинга системы и управления логами 
Цель: создать скрипт, который выполняет мониторинг системы и сохраняет результаты в лог-файлы. 
Требования:
1. Мониторинг ресурсов:
	- Используйте команды для проверки загрузки CPU, памяти, места на диске.
	- Выводите результаты в лог-файл, разделяя STDOUT и STDERR.
2. Управление логами:
	- Реализуйте ротацию логов (например, сохраняйте логи за последние 3 дня, старые удаляйте). 
3. Сигналы и обработка ошибок:
	- Добавьте обработку сигналов (SIGINT, SIGTERM), чтобы скрипт корректно завершался.
4. Отладка:
	- Добавьте опцию для вывода отладочной информации (set -x).

Результат: Рабочий скрипт, который можно запустить и проверить.

```
#!/bin/bash

# Отладка (активируется опцией -d)
if [[ "$1" == "-d" ]]; then
    set -x
fi

# Директория для логов
LOG_DIR="./monitor_logs"
mkdir -p "$LOG_DIR"

# Имена лог-файлов
STDOUT_LOG="$LOG_DIR/system_monitor_stdout.log"
STDERR_LOG="$LOG_DIR/system_monitor_stderr.log"
TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
CURRENT_LOG="$LOG_DIR/system_monitor_$TIMESTAMP.log"

# Интервал между проверками (в секундах)
INTERVAL=30

# Функция для ротации логов
rotate_logs() {
    echo -ne "\nRotating logs..."
    # Удаляем логи старше 3 дней
    find "$LOG_DIR" -name "system_monitor_*.log" -type f -mtime +3 -exec rm -f {} \;
}

# Функция для мониторинга системы
monitor_system() {
	echo -ne "\nMonitoring the system..."
    echo "=== System Monitoring Report ===" >> "$CURRENT_LOG"
    echo "Timestamp: $(date)" >> "$CURRENT_LOG"
    
    # Мониторинг CPU
    echo -e "\nCPU Usage:" >> "$CURRENT_LOG"
    top -bn1 | grep "Cpu(s)" 2>> "$STDERR_LOG" | tee -a "$CURRENT_LOG" >> "$STDOUT_LOG"
    
    # Мониторинг памяти
    echo -e "\nMemory Usage:" >> "$CURRENT_LOG"
    free -h 2>> "$STDERR_LOG" | tee -a "$CURRENT_LOG" >> "$STDOUT_LOG"
    
    # Мониторинг диска
    echo -e "\nDisk Usage:" >> "$CURRENT_LOG"
    df -h 2>> "$STDERR_LOG" | tee -a "$CURRENT_LOG" >> "$STDOUT_LOG"
    
    echo -e "\nMonitoring completed." >> "$CURRENT_LOG"
}

# Функция для обработки сигналов
cleanup() {
    echo -ne "\nReceived signal, cleaning up..."
    rotate_logs
    echo -ne "\nScript terminated gracefully.\n"
    exit 0
}

# Регистрация обработчиков сигналов
trap cleanup SIGINT SIGTERM

# Основной цикл
while true; do
    monitor_system
    rotate_logs

	# Обратный отсчет до следующей проверки
    for ((i=INTERVAL; i>=1; i--)); do
        printf "\rNext monitoring in: %02d sec (Press Ctrl+C to exit)" $i
        sleep 1
    done
    printf "\r\033[K"
done
```

![CleanShot 2025-07-10 at 16.46.36@2x.png](CleanShot%202025-07-10%20at%2016.46.36@2x.png)
# Задание 2
Система резервного копирования и проверки целостности 
Цель: автоматизировать процесс резервного копирования файлов и проверку целостности. 
Требования:
1. Создание резервных копий:
	- Напишите скрипт для инкрементального копирования файлов из заданной директории в архивы. 
	- Используйте tar или rsync для создания архивов.
2. Проверка целостности:
	- После создания архива выполните проверку целостности (например, с помощью md5sum).
3. Уведомления:
	- Если резервное копирование прошло успешно, добавьте запись в лог-файл.
	- В случае ошибки перенаправьте сообщение в STDERR.
4. Управление расписанием:
	- Настройте выполнение скрипта через cron.

Результат: полностью автоматизированная система резервного копирования.
```
#!/bin/bash

# Конфигурация
BACKUP_DIR="/home/fedor/backup_etc"
SOURCE_DIR="/etc"
LOG_DIR="/home/fedor/backup_etc/log"
LOG_FILE="$LOG_DIR/backup_$(date +%Y-%m-%d).log"
MAX_BACKUPS=5  # Максимальное количество хранимых резервных копий

# Создаем директории если их нет
mkdir -p "$BACKUP_DIR"
mkdir -p "$LOG_DIR"

# Имя файла архива с timestamp
BACKUP_FILE="$BACKUP_DIR/etc_backup_$(date +%Y-%m-%d_%H-%M-%S).tar.gz"

# Функция для записи в лог
log() {
    echo "$(date "+%Y-%m-%d %H:%M:%S") - $1" >> "$LOG_FILE"
}

# Функция для отправки уведомления об ошибке
notify_error() {
    echo "$(date "+%Y-%m-%d %H:%M:%S") - ERROR: $1" >&2
    log "ERROR: $1"
}

# Начало процесса
log "=== Начало резервного копирования /etc ==="

# Создаем инкрементальный архив
log "Создание архива $BACKUP_FILE"
if tar -czf "$BACKUP_FILE" -g "$BACKUP_DIR/etc.snar" "$SOURCE_DIR" 2>> "$LOG_FILE"; then
    log "Архив успешно создан"
else
    notify_error "Ошибка при создании архива"
    exit 1
fi

# Проверка целостности архива
log "Проверка целостности архива"
if tar -tzf "$BACKUP_FILE" &>/dev/null; then
    md5sum "$BACKUP_FILE" > "$BACKUP_FILE.md5"
    log "Проверка целостности успешна. MD5: $(cat "$BACKUP_FILE.md5")"
else
    notify_error "Архив поврежден!"
    rm -f "$BACKUP_FILE"
    exit 1
fi

# Удаляем старые резервные копии
log "Удаление старых резервных копий (оставляем последние $MAX_BACKUPS)"
cd "$BACKUP_DIR" || exit
ls -t etc_backup_*.tar.gz 2>/dev/null | tail -n +$((MAX_BACKUPS + 1)) | while read -r file; do
    log "Удаляем старый бэкап: $file"
    rm -f "$file" "$file.md5"
done

# Проверка места на диске
log "Проверка дискового пространства:"
df -h "$BACKUP_DIR" | tail -1 >> "$LOG_FILE"

log "=== Резервное копирование успешно завершено ==="
```

![CleanShot 2025-07-10 at 17.22.21@2x.png](CleanShot%202025-07-10%20at%2017.22.21@2x.png)
![CleanShot 2025-07-10 at 17.24.08@2x.png](CleanShot%202025-07-10%20at%2017.24.08@2x.png)
# Задание 3
Анализ процессов и диагностика системы 
Цель: провести диагностику системы с помощью инструментов анализа процессов.
Требования:
1. Анализ ресурсов:
	- Напишите скрипт, который запускает несколько процессов с высокой нагрузкой на CPU, память и диск.
	- Используйте top, htop и /ргос для анализа.
2. Статусы процессов:
	- Создайте процессы-зомби и сироты, проанализируйте их статус.
	- Используйте ps для вывода информации о процессах.
3. Использование strace:
	- Выполните анализ системных вызовов для команды Is с помощью strace.
	- Выведите в лог-файл список вызванных системных функций.
1. Оптимизация:
	- Измените приоритет одного из процессов (с помощью пісе или ionice) и посмотрите, как это влияет на производительность.

Результат: Отчет о поведении системы под нагрузкой и рекомендации по оптимизации.

```
#!/bin/bash

# Директория для логов
LOG_DIR="/home/fedor/system_diagnostics"
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/diagnostic_$(date +%Y-%m-%d_%H-%M-%S).log"

# Время работы нагрузки (в секундах)
LOAD_DURATION=300  # 5 минут

# Максимальный размер тестовых файлов (в MB)
MAX_DISK_USAGE=500  # Не более 500MB

# Функция для проверки дискового пространства
check_disk_space() {
    local required=$1
    local available=$(df -m --output=avail / | tail -1 | awk '{print $1}')
    
    if [ "$available" -lt "$required" ]; then
        log "ОШИБКА: Недостаточно места на диске. Нужно: ${required}M, Доступно: ${available}M"
        return 1
    fi
    return 0
}

# Функция для записи в лог
log() {
    echo -e "$(date "+%Y-%m-%d %H:%M:%S") - $1" | tee -a "$LOG_FILE"
}

# Функция для сбора метрик системы
collect_metrics() {
    local phase=$1
    log "\n=== МЕТРИКИ СИСТЕМЫ ($phase) ==="
    
    log "\nСвободное место на диске:"
    df -h | tee -a "$LOG_FILE"
    
    log "\nТоп-5 процессов по CPU:"
    ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu | head -n 6 | tee -a "$LOG_FILE"
    
    log "\nТоп-5 процессов по памяти:"
    ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%mem | head -n 6 | tee -a "$LOG_FILE"
    
    log "\nИспользование памяти:"
    free -h | tee -a "$LOG_FILE"
}

# Очистка при завершении
cleanup() {
    log "Завершение работы и очистка..."
    kill $CPU_PID $MEM_PID 2>/dev/null
    killall stress-ng fio 2>/dev/null
    rm -f /tmp/testfile /tmp/zombie_creator.sh "$FIO_TEMP_FILE"
    sync
    log "Очистка завершена. Текущее состояние диска:"
    df -h | tee -a "$LOG_FILE"
    exit
}

trap cleanup SIGINT SIGTERM

log "=== НАЧАЛО ДИАГНОСТИКИ СИСТЕМЫ ==="
log "Длительность теста: $LOAD_DURATION секунд"
collect_metrics "ДО НАГРУЗКИ"

# Проверка дискового пространства перед запуском
if ! check_disk_space $MAX_DISK_USAGE; then
    log "Прерывание выполнения из-за нехватки места"
    exit 1
fi

# 1. Создание нагрузки на систему
log "\n=== 1. СОЗДАНИЕ ИСКУССТВЕННОЙ НАГРУЗКИ ==="

# Процесс с нагрузкой на CPU (без использования диска)
log "Запуск CPU-нагруженного процесса (openssl speed)"
openssl speed -multi $(nproc) >/dev/null 2>&1 &
CPU_PID=$!

# Процесс с нагрузкой на память
log "Запуск memory-нагруженного процесса (stress-ng)"
stress-ng --vm 2 --vm-bytes 1G --timeout ${LOAD_DURATION}s >/dev/null 2>&1 &
MEM_PID=$!

# Процесс с нагрузкой на диск (с контролем размера)
log "Запуск disk-нагруженного процесса (fio с ограничением размера)"
FIO_TEMP_FILE="/tmp/fio_tempfile"
fio --name=disk-test --filename=$FIO_TEMP_FILE --size=${MAX_DISK_USAGE}M --ioengine=libaio \
    --rw=randrw --bs=4k --numjobs=2 --runtime=${LOAD_DURATION} --time_based >/dev/null 2>&1 &
DISK_PID=$!

# 2. Промежуточный мониторинг
log "\n=== 2. МОНИТОРИНГ ПОД НАГРУЗКОЙ ==="
for i in {1..3}; do
    sleep $(($LOAD_DURATION/3))
    collect_metrics "ЭТАП $i/3"
    check_disk_space 100 || { log "Критически мало места!"; cleanup; }
done

# 3. Создание специальных процессов
log "\n=== 3. СОЗДАНИЕ СПЕЦИАЛЬНЫХ ПРОЦЕССОВ ==="

# Процесс-зомби (без использования диска)
log "Создание процесса-зомби"
cat <<'EOF' > /tmp/zombie_creator.sh
#!/bin/bash
(sleep 30 &)
exec /bin/true
EOF
chmod +x /tmp/zombie_creator.sh
/tmp/zombie_creator.sh >> "$LOG_FILE" 2>&1

# 4. Анализ системных вызовов (минимальный)
log "\n=== 4. АНАЛИЗ СИСТЕМНЫХ ВЫЗОВОВ ==="
log "Запись системных вызовов (ограниченный набор)"
strace -o "$LOG_DIR/strace_ls_$(date +%Y-%m-%d_%H-%M-%S).log" ls / >/dev/null 2>&1

# 5. Завершение
cleanup
```

[diagnostic_2025-07-10_22-35-48.log](diagnostic_2025-07-10_22-35-48.log)]
[strace_ls_2025-07-10_22-40-48.log](strace_ls_2025-07-10_22-40-48.log)
# Задание 4
Автоматизация управления пользователями 
Цель: создать скрипт для управления пользователями системы.
Требования:
1. Создание пользователей:
	- Напишите скрипт, который создает пользователей на основе данных из CSV файла.
	- Задайте каждому пользователю домашнюю директорию, сгенерируйте SSH-ключи и назначьте пароль.
2. Управление группами:
	- Добавьте пользователей в группы в зависимости от их роли.
	- Проверьте и обновите права доступа на директории, связанные с группами.
3. Логи и отчеты:
	- Все изменения записывайте в лог-файл (например, созданные пользователи, ошибки).
4. Удаление пользователей:
	- Добавьте функционал для удаления пользователей, указанных в другом CSV файле, с возможностью удаления их домашней директории.
Результат: Готовый скрипт для массового управления пользователями.

```
#!/bin/bash

# Конфигурация
LOG_FILE="/var/log/user_manager_$(date +%Y%m%d).log"
SSH_KEY_TYPE="ed25519"
BACKUP_DIR="/backup/deleted_users"

# Функция логирования
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# Проверка на root
check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        log "ОШИБКА: Скрипт должен запускаться с правами root!"
        exit 1
    fi
}

# Создание пользователей из CSV
create_users() {
    local csv_file="$1"
    
    if [ ! -f "$csv_file" ]; then
        log "Файл $csv_file не найден!"
        return 1
    fi

    log "Начало создания пользователей из $csv_file"
    
    # Чтение CSV (формат: username,password,role,fullname)
    while IFS=',' read -r username password role fullname; do
        # Пропускаем заголовок
        if [ "$username" == "username" ]; then
            continue
        fi

        log "Обработка пользователя: $username ($fullname), роль: $role"
        
        # Проверка существования пользователя
        if id "$username" &>/dev/null; then
            log "Пользователь $username уже существует, пропускаем"
            continue
        fi

        # Создание пользователя
        useradd -m -c "$fullname" -s /bin/bash "$username"
        if [ $? -ne 0 ]; then
            log "ОШИБКА: Не удалось создать пользователя $username"
            continue
        fi

        # Установка пароля
        echo "$username:$password" | chpasswd
        log "Пароль для $username установлен"

        # Создание SSH ключей
        su - "$username" -c "ssh-keygen -t $SSH_KEY_TYPE -f ~/.ssh/id_$SSH_KEY_TYPE -N '' -q"
        log "SSH ключи для $username созданы"

        # Добавление в группы по роли
        case "$role" in
            admin)
                usermod -aG sudo,adm "$username"
                ;;
            developer)
                usermod -aG dev "$username"
                ;;
            analyst)
                usermod -aG analysts "$username"
                ;;
            *)
                usermod -aG users "$username"
                ;;
        esac
        log "Пользователь $username добавлен в группы для роли $role"

        # Настройка прав на домашнюю директорию
        chmod 750 "/home/$username"
        log "Права на домашнюю директорию установлены"

    done < "$csv_file"
    
    log "Создание пользователей завершено"
}

# Удаление пользователей из CSV
delete_users() {
    local csv_file="$1"
    local remove_home="$2"
    
    if [ ! -f "$csv_file" ]; then
        log "Файл $csv_file не найден!"
        return 1
    fi

    log "Начало удаления пользователей из $csv_file"
    mkdir -p "$BACKUP_DIR"
    
    # Чтение CSV (формат: username,...)
    while IFS=',' read -r username _; do
        # Пропускаем заголовок и пустые строки
        if [ "$username" == "username" ] || [ -z "$username" ]; then
            continue
        fi

        log "Обработка пользователя для удаления: $username"
        
        # Проверка существования пользователя
        if ! id "$username" &>/dev/null; then
            log "Пользователь $username не существует, пропускаем"
            continue
        fi

        # Архивирование домашней директории
        local backup_file="$BACKUP_DIR/${username}_$(date +%Y%m%d).tar.gz"
        if [ -d "/home/$username" ]; then
            tar -czf "$backup_file" -C /home "$username"
            log "Домашняя директория $username сохранена в $backup_file"
        fi

        # Удаление пользователя
        local options=""
        if [ "$remove_home" == "yes" ]; then
            options="--remove"
        fi
        
        if userdel $options "$username"; then
            log "Пользователь $username успешно удален"
        else
            log "ОШИБКА: Не удалось удалить пользователя $username"
        fi

    done < "$csv_file"
    
    log "Удаление пользователей завершено"
}

# Обновление прав для групп
update_group_permissions() {
    log "Обновление прав для групп"
    
    [ -d "/var/www/dev" ] && chgrp -R dev /var/www/dev && chmod -R 2775 /var/www/dev
    [ -d "/var/data/analysts" ] && chgrp -R analysts /var/data/analysts && chmod -R 2770 /var/data/analysts
    
    log "Права для групп обновлены"
}

# Основное меню
main_menu() {
    echo "
=== Управление пользователями ===
1) Создать пользователей из CSV
2) Удалить пользователей из CSV (сохранить домашнюю директорию)
3) Удалить пользователей из CSV (удалить домашнюю директорию)
4) Обновить права для групп
5) Выход
"
    read -p "Выберите действие: " choice

    case $choice in
        1)
            read -p "Введите путь к CSV файлу: " csv_file
            create_users "$csv_file"
            ;;
        2)
            read -p "Введите путь к CSV файлу: " csv_file
            delete_users "$csv_file" "no"
            ;;
        3)
            read -p "Введите путь к CSV файлу: " csv_file
            delete_users "$csv_file" "yes"
            ;;
        4)
            update_group_permissions
            ;;
        5)
            exit 0
            ;;
        *)
            echo "Неверный выбор"
            ;;
    esac
}

# Точка входа
check_root
mkdir -p "$(dirname "$LOG_FILE")"
touch "$LOG_FILE"

while true; do
    main_menu
done
```

![CleanShot 2025-07-11 at 15.35.49@2x.png](CleanShot%202025-07-11%20at%2015.35.49@2x.png)
![CleanShot 2025-07-11 at 15.36.36@2x.png](CleanShot%202025-07-11%20at%2015.36.36@2x.png)
![CleanShot 2025-07-11 at 15.38.38@2x.png](CleanShot%202025-07-11%20at%2015.38.38@2x.png)
