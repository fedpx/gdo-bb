# Задание 1 
Введение в процессы 
1. Определите, какие процессы выполняются в вашей системе:
	- Выполните команду ps -aux и найдите ваш shell-процесс.
	- Найдите процессы с самым высоким использованием CPU и памяти.
2. Выведите дерево процессов:
	- Используйте команду pstree и определите родительские процессы для запущенных приложений.

![CleanShot 2025-07-14 at 21.03.49@2x.png](CleanShot%202025-07-14%20at%2021.03.49@2x.png)
![CleanShot 2025-07-14 at 21.04.51@2x.png](CleanShot%202025-07-14%20at%2021.04.51@2x.png)

---
# Задание 2
Создание и управление процессами 
1. Запустите команду в фоновом режиме:
	- Выполните ping google.com › output.log&.
	- Переведите процесс на передний план.
	- Приостановите выполнение и возобновите в фоновом режиме.
2. Установите приоритеты процессам:
	- Запустите команду yes › /dev/null &.
	- Используйте top, чтобы найти процесс, и измените его приоритет с помощью renice.
3. Остановите процесс:
	- Найдите PID с помощью ps и завершите процесс с помощью kill.

## **1. Запуск команды в фоновом режиме и управление процессом**

### **1.1. Запуск `ping` в фоне с записью в файл**
```
ping google.com > output.log &
```
- `>` — перенаправляет вывод в файл `output.log`. 
- `&` — запускает процесс в **фоновом режиме**.

### **1.2. Перевести процесс на передний план (`fg`)**
```
fg %1  # где %1 — номер задачи (job), а не PID
```
### **1.3. Приостановка и возобновление в фоне**
1. **Приостановка (`Ctrl + Z`)**
    - Нажмите `Ctrl + Z`, если процесс на переднем плане.
    - Вывод:
```
[1]+  Stopped                 ping google.com > output.log
``` 
2. **Возобновление в фоне (`bg`)**
```
bg %1  # продолжить выполнение в фоне
```
## **2. Установка приоритетов (`nice` и `renice`)**
### **2.1. Запуск `yes` в фоне (нагружает CPU)**
```
yes > /dev/null &
```
- `yes` — бесконечно выводит `y`, нагружая CPU.
- `> /dev/null` — отправляет вывод в "никуда".
### **2.2. Поиск процесса в `top`**
```
top
```
- Найти процесс `yes` (обычно высокий %CPU).
- Запомнить его **PID** (первый столбец).
### **2.3. Изменение приоритета (`renice`)**
```
renice -n 10 -p PID  # где PID — номер процесса
```
- `-n 10` — устанавливает **nice** значение `10` (низкий приоритет).
- Чем выше nice (от `-20` до `19`), тем ниже приоритет.
## **3. Остановка процесса (`kill`)**
### **3.1. Поиск PID процесса `yes`**
```
ps aux | grep yes
```
**Вывод:**
```
user     12345  90  0.1  1234  5678 pts/0    R    10:00   0:05 yes
```
- `12345` — PID процесса.
### **3.2. Завершение процесса (`kill`)**
```
kill -9 12345  # SIGKILL (принудительное завершение)
```
- `-9` — сигнал **SIGKILL** (нельзя игнорировать).
- Можно использовать `kill 12345` (по умолчанию `SIGTERM` — мягкое завершение).

![CleanShot 2025-07-15 at 00.22.00@2x.png](CleanShot%202025-07-15%20at%2000.22.00@2x.png)
![CleanShot 2025-07-15 at 00.22.16@2x.png](CleanShot%202025-07-15%20at%2000.22.16@2x.png)
![CleanShot 2025-07-15 at 00.23.12@2x.png](CleanShot%202025-07-15%20at%2000.23.12@2x.png)
![CleanShot 2025-07-15 at 00.23.01@2x.png](CleanShot%202025-07-15%20at%2000.23.01@2x.png)
![CleanShot 2025-07-15 at 00.25.37@2x.png](CleanShot%202025-07-15%20at%2000.25.37@2x.png)

---
# Задание 3
Мониторинг процессов
1. Запустите top и ответьте на вопросы:
	- Какие процессы занимают больше всего CPU?
	- Как меняется нагрузка, если запустить stress или yes › /dev/null &?
2. Используйте htop для мониторинга:
	- Найдите процесс, идущий в фоновом режиме.
	- Измените приоритет (Nice) прямо в интерфейсе.
3. Изучите историю работы системы с помощью atop:
	- Установите atop и запустите его с записью логов.
	- Откройте лог и проанализируйте данные.

![CleanShot 2025-07-15 at 14.01.18@2x.png](CleanShot%202025-07-15%20at%2014.01.18@2x.png)
![CleanShot 2025-07-15 at 14.02.22@2x.png](CleanShot%202025-07-15%20at%2014.02.22@2x.png)
![CleanShot 2025-07-15 at 14.31.51@2x.png](CleanShot%202025-07-15%20at%2014.31.51@2x.png)
![CleanShot 2025-07-15 at 18.58.58@2x.png](CleanShot%202025-07-15%20at%2018.58.58@2x.png)

---
# Задание 4
Файлы и процессы 
1. Исследуйте директорию `/proc`:
	- Найдите ваш shell-процесс с помощью команды ps.
	- Откройте `/proc/[PID]/stat` и объясните значения.
	- Определите, какие файлы открыты процессом, используя `lsof`.
2. Посмотрите открытые файловые дескрипторы:
	- Запустите `cat › /dev/null &` в фоне.
	- Откройте `/proc/[PID]/fd` и проверьте, какие файлы открыты.
3. Проанализируйте использование памяти:
	- Изучите содержимое `/proc/meminfo` и сравните с данными в `free -h`.

## **1. Исследование `/proc` и процессов**
### **1.1. Найти PID своего shell-процесса**
```
ps -aux | grep "bash\|zsh"  # или ваш shell (fish, sh и т. д.)
```
### **1.2. Анализ `/proc/[PID]/stat`**
```
cat /proc/1234/stat
```
**Пример вывода (разберём ключевые поля):**
```
1234 (bash) S 567 1234 1234 34816 7890 0 0 0 0 0 5 1 0 0 20 0 1 0 2987123 987654 321 18446744073709551615 947872 947944 140736 0 0 0 0 3686404 1266761467 0 0 0 17 3 0 0 0 0 0 947976 948040 1146880 0 0 0 0 0 0 0 0 0 0 0
```
**Основные значения (порядок важен!):**
1. **PID** — `1234` (идентификатор процесса).
2. **Имя** — `bash` (заключено в скобки).
3. **Состояние (State)** — `S` (`S` = спящий, `R` = работает, `Z` = зомби).
4. **PPID** — `567` (PID родительского процесса).
5. **Приоритет (Priority)** — `20` (значение `nice`).
6. **Виртуальная память (VSZ)** — `2987123` (в байтах).
7. **RSS (Resident Set Size)** — `987654` (физическая память в байтах).
### **1.3. Какие файлы открыты процессом? (`lsof`)**
```
sudo lsof -p 1234
```
**Пример вывода:**
```
COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
bash    1234 user  cwd    DIR   8,1     4096 1234567 /home/user
bash    1234 user  txt    REG   8,1  1234567 7654321 /bin/bash
bash    1234 user  mem    REG   8,1  5678901 1122334 /lib/x86_64-linux-gnu/libc.so.6
```
- **FD** (File Descriptor):
    - `cwd` — текущая рабочая директория.        
    - `txt` — исполняемый файл процесса.
    - `mem` — файлы, загруженные в память.
## **2. Открытые файловые дескрипторы (`/proc/[PID]/fd`)**
### **2.1. Запуск `cat` в фоне**
```
cat > /dev/null &
```
**Вывод:**
```
[1] 2345  # PID = 2345
```
### **2.2. Просмотр `/proc/[PID]/fd`**
```
ls -la /proc/2345/fd
```
**Пример вывода:**
```
total 0
lrwx------ 1 user user 64 Jul 15 10:00 0 -> /dev/pts/0
lrwx------ 1 user user 64 Jul 15 10:00 1 -> /dev/null
lrwx------ 1 user user 64 Jul 15 10:00 2 -> /dev/pts/0
```
- **`0`** — stdin (ввод с терминала).
- **`1`** — stdout (перенаправлен в `/dev/null`).
- **`2`** — stderr (вывод ошибок в терминал).
## **3. Анализ памяти (`/proc/meminfo` и `free`)**
### **3.1. Просмотр `/proc/meminfo`**
```
cat /proc/meminfo
```
**Ключевые поля:**
- **MemTotal** — общая память.
- **MemFree** — свободная память.
- **Buffers** — буферы ядра.
- **Cached** — кеш файлов.
- **SwapTotal** и **SwapFree** — своп-память.
**Пример:**
```
MemTotal:        8167848 kB
MemFree:         2345678 kB
Buffers:          123456 kB
Cached:          3456789 kB
SwapTotal:       2097148 kB
SwapFree:        2097148 kB
```
### **3.2. Сравнение с `free -h`**
```
free -h
```
**Вывод:**
```
              total    used    free  shared  buff/cache   available
Mem:          7.8G    3.2G    2.2G    123M        2.4G        4.1G
Swap:         2.0G      0B    2.0G
```
**Сопоставление:**
- `MemTotal` (из `/proc/meminfo`) = `total` в `free`.
- `MemFree` + `Buffers` + `Cached` ≈ `free` + `buff/cache`.

![CleanShot 2025-07-15 at 19.31.10@2x.png](CleanShot%202025-07-15%20at%2019.31.10@2x.png)
![CleanShot 2025-07-15 at 19.33.39@2x.png](CleanShot%202025-07-15%20at%2019.33.39@2x.png)
![CleanShot 2025-07-15 at 19.36.24@2x.png](CleanShot%202025-07-15%20at%2019.36.24@2x.png)
![CleanShot 2025-07-15 at 19.36.17@2x.png](CleanShot%202025-07-15%20at%2019.36.17@2x.png)

