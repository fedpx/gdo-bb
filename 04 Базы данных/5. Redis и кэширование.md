# Задание
## 1. Установка Redis
- Ha Linux-сервере установите Redis с помощью пакетного менеджера. Пример для Ubuntu: sudo apt update sudo apt install redis-server
- Запустите Redis и убедитесь, что сервис работает корректно: 
```
sudo systemctl start redis-server 
sudo systemctl status redis-server 
```
- Подключитесь к Redis-клиенту и выполните несколько команд (PING, SET, GET), чтобы проверить, что база данных функционирует: 
```
redis-cli
› PING > SET example "Hello, Redis!"
› GET example
```
## 2. Настройка конфигураций Redis 
Изучите конфигурационный файл Redis (`/etc/redis/redis.conf`) и внесите изменения для повышения безопасности
- Ограничьте доступ к Redis только для localhost, изменив параметр bind: `bind 127.0.0.1`
- Установите пароль для подключения к Redis, добавив параметр requirepass: `requirepass yourpassword`
- Перезапустите Redis для применения изменений: `sudo systemctl restart redis-server`
## 3. Работа с базами данных 
Используйте несколько баз данных Redis, переключаясь между ними с помощью команды SELECT. Вставьте данные в разные базы данных и убедитесь, что данные из одной базы недоступны в другой 
```
SELECT 0
SET key1 "Value in DB 0"
SELECT 1 
GET key1
```
## 4. Кэширование данных 
- Попробуйте использовать Redis для кэширования: создайте ключи с временным сроком действия (TTL). Установите ключ с временем жизни в 60 секунд и убедитесь, что по истечении времени он удаляется 
```
SET temp_key "Temporary Data" EX 60 
GET temp_key 
```
- Используйте команду TTL, чтобы проверить оставшееся время жизни ключа.
## 5. Хранение данных в различных структурах 
Создайте ключи, используя различные структуры данных Redis 
- Список. Добавьте несколько элементов и извлеките их.
```
RPUSH mylist "element1" "element2" "element3"
LRANGE mylist 0 -1 
```
- Множество. Добавьте элементы и проверьте уникальность.
```
SADD myset "item1" "item2" "item1"
SMEMBERS myset 
```
- Хеш. Сохраните и извлеките данные как в JSON-структуре.
```
HSET user: 1000 name "Alice" age "30"
HGETALL user:1000
```
## 6.Команда INFO
Используйте команду INFO для получения статистики по ключевым параметрам Redis, таким как использование памяти и количество подключений. Проверьте секции Memory, Clients и Persistence. 
```
INFO Memory 
INFO Clients 
INFO Persistence
```
## 7. Проверка эффективности 
- Установите ограничение на память с параметром тахтетогу и выберите eviction-политику в конфигурационном файле redis.conf. После перезапуска Redis вставьте данные, пока не будет достигнут лимит памяти, и проверьте, как происходит удаление старых ключей.
- Используйте команды для мониторинга использования памяти:
```
CONFIG SET maxmemory 100mb 
CONFIG SET maxmemory-policy allkeys-lru
```
- Проверьте, как используется память до и после удаления данных, с помощью команды MEMORY USAGE.
## 8. Резервирование данных 
- Настройте резервное копирование данных с помощью режима RDB, который автоматически создает снапшоты. Измените параметры в redis.conf для настройки интервала бэкапов и проверьте, где создаются резервные файлы.
- Проверьте, что данные сохраняются на диск, после чего остановите и перезапустите Redis. Убедитесь, что данные восстанавливаются после перезапуска.

# Шаг 0. Подготовка томов и конфига
Создадим каталог для конфига и персистентные тома:
```
sudo mkdir -p /opt/redis sudo chown -R $USER:$USER /opt/redis docker volume create redis_data
```
Соберём минимальный `redis.conf` с безопасными настройками (локальный порт, пароль, RDB-снапшоты и лимиты памяти для задания):
```
cat >/opt/redis/redis.conf <<'EOF' 
# Слушаем только внутри контейнера; наружу пробросим на 127.0.0.1 
bind 0.0.0.0 
protected-mode yes 
port 6379  

# Пароль (замени на свой сильный, можно оставить для учебного задания) requirepass SuperSecret!123  

# Кол-во БД по умолчанию 
databases 16  

# Снапшоты RDB (по умолчанию: 900/1, 300/10, 60/10000) 
save 900 1 
save 300 10 
save 60 10000 
dbfilename dump.rdb 
dir /data  

# Лимит памяти и политика вытеснения (для Шага 7; можно менять на лету) 
maxmemory 100mb 
maxmemory-policy 
allkeys-lru 
EOF
```
---
# Шаг 1. Поднять Redis в Docker
Запускаем контейнер с монтированием конфига и данных. Публикуем порт только на `127.0.0.1` (доступ только с самой VM):
```
docker run -d --name redis \   
	-p 127.0.0.1:6379:6379 \   
	-v /opt/redis/redis.conf:/usr/local/etc/redis/redis.conf:ro \   
	-v redis_data:/data \   
	redis:7 \   
	redis-server /usr/local/etc/redis/redis.conf
```
Проверка:
```
docker ps --filter name=redis
```
**Пришли:** строку из `docker ps`.

---
# Шаг 2. Базовая проверка (PING / SET / GET)
Подключимся `redis-cli` из контейнера:
```
docker exec -it redis redis-cli
```
Внутри клиента:
```
AUTH SuperSecret!123 
PING 
SET example "Hello, Redis!" 
GET example 
QUIT
```
**Пришли:** ответы на `PING` и `GET`.

---
# Шаг 3. Конфигурация и безопасность (аналог правки redis.conf)
Мы уже задали:
- `bind 0.0.0.0` внутри контейнера + публикация на `127.0.0.1` снаружи → извне хоста недоступно.
- `requirepass SuperSecret!123` → требование пароля.
- Для изменения «на лету» можно использовать:
```
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli CONFIG GET requirepass
```

```
docker exec redis sh -lc "grep -n '^requirepass' /usr/local/etc/redis/redis.conf"
```
Перезапуск с конфигом:
```
docker restart redis
```
**Пришли:** вывод `CONFIG GET requirepass` (две строки OK).

---
# Шаг 4. Работа с несколькими БД (SELECT)
```
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli
SELECT 0 
SET key1 "Value in DB 0" 
SELECT 1 
GET key1 
SELECT 0 
GET key1 
```
Ожидаемо: в DB 1 ключа нет (nil), в DB 0 — есть.

**Пришли:** три строки с ответами `OK`/`nil`/значение.

---
# Шаг 5. Кэширование с TTL
```
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli
SET temp_key "Temporary Data" EX 60 
TTL temp_key 
GET temp_key
```
(Через ~60 сек `GET temp_key` вернёт `(nil)`. Можно проверить ещё раз.)

**Пришли:** первые два ответа (TTL должен быть 1..60), и итоговый `(nil)` после ожидания.

---
# Шаг 6. Структуры данных: List, Set, Hash
```
# List 
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli RPUSH mylist "element1" "element2" "element3" 
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli LRANGE mylist 0 -1  

# Set (проверка уникальности) 
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli SADD myset "item1" "item2" "item1" 
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli SMEMBERS myset  

# Hash (как JSON-объект) 
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli HSET user:1000 name "Alice" age "30" 
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli HGETALL user:1000
```
**Пришли:** результаты `LRANGE`, `SMEMBERS`, `HGETALL`.

---
# Шаг 7. Команда INFO (Memory / Clients / Persistence)
```
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli 
INFO Memory | head -n 20 
INFO Clients 
INFO Persistence
```
**Пришли:** по 3–5 строк из каждой секции (ключевые поля).

---
# Шаг 8. Проверка эффективности: maxmemory + eviction

Мы уже задали `maxmemory 100mb` и `allkeys-lru` в конфиге. Создадим много ключей, чтобы достичь лимита, и посмотрим вытеснение.

Заполняем базу данными ~по 1 КБ:
```
# Сгенерим 1КБ строку и загрузим ~200kB/сек до упора (зависит от машины)
PAYLOAD=$(python3 - <<'PY'
print("x"*1024)
PY
)
# Вариант через bash-цикл:
for i in $(seq 1 200000); do
  docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli  SET "k:$i" "$PAYLOAD" > /dev/null || break
done
```
Проверим статистику и выборочную память:
```
docker exec -e REDISCLI_AUTH='SuperSecret!123' -it redis redis-cli
INFO Memory | egrep 'used_memory_human|maxmemory_human|evicted_keys'
MEMORY USAGE k:100
MEMORY USAGE k:200
```
Если лимит сработал, `evicted_keys` станет > 0, и старые ключи начнут исчезать по LRU.

**Пришли:** строка с `used_memory_human`, `maxmemory_human`, `evicted_keys`, и 1–2 значения `MEMORY USAGE`.

> Хотите оперативно менять без перезапуска — можно:  
> `docker exec -it redis redis-cli -a SuperSecret!123 CONFIG SET maxmemory 120mb`  
> `docker exec -it redis redis-cli -a SuperSecret!123 CONFIG SET maxmemory-policy allkeys-lfu`

---
# Шаг 9. RDB‑резервирование и восстановление при рестарте
Мы включили `save` и `dir /data`, а том `redis_data` смонтирован, значит `dump.rdb` будет сохраняться в том.
1. Убедимся, что снапшот создаётся (форсируем `BGSAVE`):
```
docker exec -it redis redis-cli -a SuperSecret!123 BGSAVE docker exec redis sh -lc 'ls -l /data && ls -l /data/dump.rdb'
```
2. Добавим «контрольный» ключ и перезапустим контейнер:
```
docker exec -it redis redis-cli -a SuperSecret!123 SET persist_key "I survive restarts" docker restart redis sleep 2 docker exec -it redis redis-cli -a SuperSecret!123 GET persist_key
```
**Пришли:** `ls -l /data/dump.rdb` и значение `GET persist_key` после рестарта (должно быть `"I survive restarts"`).
