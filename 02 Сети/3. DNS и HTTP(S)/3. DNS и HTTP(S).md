# Задания
## Задание 1
### Настройка и анализ DNS-запросов 
1. Установите утилиты для работы с DNS-запросами, например dnsutils (включает команды dig и nslookup).
2. Выполните анализ DNS-запросов:
	- Определите IP-адрес для домена (например, www.example.com).
	- Найдите серверы имен (NS-записи) для домена.
	- Проверьте почтовые серверы (МХ-записи) для домена.
	- Определите обратное разрешение (PTR-запись) для IP-адреса.

Конечный результат: Должны быть получены корректные данные для всех типов записей.
#### **1. Определение IP-адреса домена (A-запись)**
**Команда:**
```
dig www.example.com A +short
```
**Или через `nslookup`:**
```
nslookup www.example.com
```
#### **2. Поиск серверов имен (NS-записи)**
**Команда:**
```
dig example.com NS +short
```
**Или:**
```
nslookup -type=ns example.com
```
#### **3. Проверка почтовых серверов (MX-записи)**
**Команда:**
```
dig example.com MX +short
```
**Или:**
```
nslookup -type=mx example.com
```
#### **4. Определение обратного DNS (PTR-запись для IP-адреса)**
**Команда:**
```
dig -x 93.184.216.34 +short
```
**Или:**
```
nslookup 93.184.216.34
```

![CleanShot 2025-07-21 at 14.54.10@2x.png](CleanShot%202025-07-21%20at%2014.54.10@2x.png)
## Задание 2
### Построение локального DNS-сервера 
1. Установите сервер BIND (или альтернативное ПО для DNS).
2. Настройте локальную зону:
	- Определите домен (например, local test) и настройте для него записи (A, CNAME и другие).
	- Укажите зоны и их параметры в конфигурации DNS-сервера.
3. Перезапустите DNS-сервер.
4. Проверьте работу зоны, отправив DNS-запрос к локальному серверу.

Конечный результат: Локальный домен (например, www.local.test) должен разрешаться в указанный IP-адрес.

### **1. Установка BIND9**
#### **Ubuntu/Debian**
```
sudo apt update
sudo apt install bind9 bind9-utils -y
```
#### **CentOS/RHEL**
```
sudo yum install bind bind-utils -y
```
Проверим статус:
```
sudo systemctl status named   # CentOS
sudo systemctl status bind9  # Ubuntu
```
---

### **2. Настройка локальной зоны**
#### **1. Создаём зону `local.test`**
Открываем конфиг `/etc/bind/named.conf.local` (Ubuntu) или `/etc/named.conf` (CentOS):
#### **Ubuntu/Debian**
```
sudo nano /etc/bind/named.conf.local
```
Добавляем:
```
bind

zone "local.test" {
    type master;
    file "/etc/bind/zones/db.local.test";
};
```
#### **CentOS/RHEL**
```
sudo nano /etc/named.conf
```
Добавляем в конец:
```
zone "local.test" {
    type master;
    file "/var/named/db.local.test";
};
```
---
#### **2. Создаём файл зоны**

#### **Ubuntu/Debian**
```
sudo mkdir -p /etc/bind/zones
sudo nano /etc/bind/zones/db.local.test
```
#### **CentOS/RHEL**
```
sudo nano /var/named/db.local.test
```
#### **Содержимое файла (`db.local.test`)**
```
$TTL 86400
@       IN      SOA     ns1.local.test. admin.local.test. (
                          2024072101 ; Serial
                          3600       ; Refresh
                          1800       ; Retry
                          604800     ; Expire
                          86400      ; Minimum TTL
)

; NS-записи (DNS-серверы)
@       IN      NS      ns1.local.test.
ns1     IN      A       192.168.1.100  ; IP DNS-сервера

; A-записи (домены → IP)
@       IN      A       192.168.1.100
www     IN      A       192.168.1.100
mail    IN      A       192.168.1.101

; CNAME-записи (алиасы)
web     IN      CNAME   www

> **Примечание:**
> 
> - `192.168.1.100` — замените на IP вашего сервера.
>     
> - `admin.local.test` — email администратора (с заменой `@` на `.`).
>     
```
---

#### **3. Проверка синтаксиса**
```
sudo named-checkconf  # Проверка основного конфига
sudo named-checkzone local.test /etc/bind/zones/db.local.test  # Ubuntu
sudo named-checkzone local.test /var/named/db.local.test       # CentOS
```
---
### **3. Перезапуск DNS-сервера**
```
sudo systemctl restart bind9   # Ubuntu
sudo systemctl restart named   # CentOS
```
---
### **4. Проверка работы DNS**
#### **1. Настроим локальный резолвер**
Отредактируем `/etc/resolv.conf`:
```
sudo nano /etc/resolv.conf
```
Добавим:
```
nameserver 192.168.1.100  # IP вашего DNS-сервера
```
> **Внимание!** В некоторых системах (особенно с `systemd-resolved`) изменения могут сбрасываться.  
> **Альтернатива:**
> `sudo systemctl disable systemd-resolved --now`

---
#### **2. Тестируем DNS-запросы**
##### **A-запись (домен → IP)**
```
dig www.local.test @192.168.1.100 +short
```
**Ожидаемый вывод:**
```
192.168.1.100
```
##### **CNAME-запись (алиас)**
```
dig web.local.test @192.168.1.100 +short
```
**Ожидаемый вывод:**
```
www.local.test.
192.168.1.100
```
##### **NS-запись (DNS-сервер зоны)**
```
dig local.test NS +short @192.168.1.100
```
**Ожидаемый вывод:**
```
ns1.local.test.
```

![CleanShot 2025-07-21 at 15.22.47@2x.png](CleanShot%202025-07-21%20at%2015.22.47@2x.png)

## Задание 3
### Работа с НТТР-запросами 
1. Установите инструмент для работы с НТТР-запросами, например curl или Postman.
2. Выполните следующие запросы:
	- GET-запрос к публичному сайту.
	- POST-запрос с тестовыми данными к АРІ (например, тестовому АРІhttps://jsonplaceholder.typicode.com/).
	- PUT-запрос для обновления данных на том же API.
	- DELETE-запрос для удаления данных.

Конечный результат: Сервер должен возвращать успешные статусы (например, 200, 201, 204) в зависимости от типа запроса.

## **1. Установка инструментов**
### **curl** (уже предустановлен в большинстве Linux)
Проверим:
```
curl --version
```
Если нет — установим:
```
sudo apt install curl -y  # Ubuntu/Debian
sudo yum install curl -y  # CentOS/RHEL
```
## **2. Выполнение HTTP-запросов**
### **1. GET-запрос (получение данных)**
**Пример:** Запрос к `https://jsonplaceholder.typicode.com/posts/1`.
#### **Через curl:**
```
curl -X GET "https://jsonplaceholder.typicode.com/posts/1" -H "Accept: application/json"
```
**Вывод:**
```
{
  "userId": 1,
  "id": 1,
  "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
  "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
}
```
**Статус:** `200 OK` (успех).
### **2. POST-запрос (создание данных)**
**Пример:** Отправка JSON-данных на `https://jsonplaceholder.typicode.com/posts`.
#### **Через curl:**
```
curl -X POST "https://jsonplaceholder.typicode.com/posts" \
-H "Content-Type: application/json" \
-d '{
  "title": "foo",
  "body": "bar",
  "userId": 1
}'
```
**Вывод:**
```
{
  "id": 101  # Новый созданный ID
}
```
**Статус:** `201 Created` (успешное создание).
### **3. PUT-запрос (обновление данных)**
**Пример:** Обновление поста с `id=1` на `https://jsonplaceholder.typicode.com/posts/1`.
#### **Через curl:**
```
curl -X PUT "https://jsonplaceholder.typicode.com/posts/1" \
-H "Content-Type: application/json" \
-d '{
  "title": "updated title",
  "body": "updated body",
  "userId": 1
}'
```
**Вывод:**
```
{
  "id": 1,
  "title": "updated title",
  "body": "updated body",
  "userId": 1
}
```
**Статус:** `200 OK` (успешное обновление).
### **4. DELETE-запрос (удаление данных)**
**Пример:** Удаление поста с `id=1` (`https://jsonplaceholder.typicode.com/posts/1`).
#### **Через curl:**
```
curl -X DELETE "https://jsonplaceholder.typicode.com/posts/1"
```
**Вывод:**
```
{}
```
**Статус:** `200 OK` или `204 No Content` (успешное удаление).

![CleanShot 2025-07-21 at 15.28.16@2x.png](CleanShot%202025-07-21%20at%2015.28.16@2x.png)
## Задание 4
### Генерация и установка SSL-сертификата 
1. Установите OpenSSL для создания сертификатов.
2. Сгенерируйте самоподписанный SSL-сертификат:
	- Укажите параметры сертификата (домен, организация, срок действия).
	- Создайте закрытый ключ и публичный сертификат. 
3. Настройте веб-сервер (например, Nginx) для использования сертификата.
4. Откройте сайт в браузере или отправьте запрос с помощью curl.

Конечный результат: Сайт доступен по HTTPS, при этом может отображаться предупреждение о ненадежном сертификате.

### **1. Установка OpenSSL**
Проверим, установлен ли OpenSSL:
```
openssl version
```
Если нет — установим:
```
sudo apt update && sudo apt install openssl -y  # Ubuntu/Debian
sudo yum install openssl -y                    # CentOS/RHEL
```
---
### **2. Генерация самоподписанного SSL-сертификата**
#### **1. Создаём папку для сертификатов**
```
sudo mkdir -p /etc/nginx/ssl
cd /etc/nginx/ssl
```
#### **2. Генерируем закрытый ключ (`private.key`)**
```
sudo openssl genpkey -algorithm RSA -out private.key -pkeyopt rsa_keygen_bits:2048
```
> 🔑 **Примечание:**
> - `2048` — стандартный размер ключа (можно 4096, но это дольше).
> - Если нужен пароль на ключ, добавьте `-aes256`.
#### **3. Создаём запрос на подпись (`CSR`)**
```
sudo openssl req -new -key private.key -out request.csr
```
**Заполняем данные:**
- **Country Name (2 буквы)**: `RU`
- **State or Province**: `Moscow`
- **Locality (City)**: `Moscow`
- **Organization Name**: `My Company`
- **Organizational Unit**: `IT`
- **Common Name (домен)**: `localhost` (или ваш домен, например `mysite.local`)
- **Email**: `admin@example.com`
- **Пароль (можно оставить пустым)**
#### **4. Генерируем самоподписанный сертификат (`certificate.crt`)**
```
sudo openssl x509 -req -days 365 -in request.csr -signkey private.key -out certificate.crt
```
> ⏳ **Срок действия:** `365` дней (можно увеличить).
### **5. Проверяем сертификат**
```
sudo openssl x509 -in certificate.crt -text -noout
```
**Вывод должен содержать:**
- Issuer (ваши данные)
- Validity (срок действия)
- Public Key (алгоритм шифрования)
---
### **3. Настройка Nginx для HTTPS**
#### **1. Редактируем конфиг Nginx**
```
sudo nano /etc/nginx/sites-available/default
```
**Добавляем блок `server` для HTTPS:**
```
server {
    listen 443 ssl;
    server_name localhost;  # или ваш домен

    ssl_certificate /etc/nginx/ssl/certificate.crt;
    ssl_certificate_key /etc/nginx/ssl/private.key;

    root /var/www/html;
    index index.html;

    location / {
        try_files $uri $uri/ =404;
    }
}

server {
    listen 80;
    server_name localhost;
    return 301 https://$host$request_uri;  # Редирект HTTP → HTTPS
}
```
#### **2. Проверяем конфиг и перезапускаем Nginx**
```
sudo nginx -t  # Проверка синтаксиса
sudo systemctl restart nginx
```
---
### **4. Проверка работы HTTPS**
#### **1. Через браузер**
Откройте:
```
https://localhost
```
> ⚠️ **Браузер предупредит, что сертификат недоверенный** — это нормально (мы его сами создали).  
> В Chrome/Firefox нажмите **"Дополнительно" → "Принять риск и продолжить"**.
### **2. Через `curl`**
```
curl -k https://localhost
```
> 🔑 `-k` — игнорировать проверку сертификата.

**Вывод:**
```
Должна открыться главная страница Nginx.
```

![CleanShot 2025-07-21 at 15.31.15@2x.png](CleanShot%202025-07-21%20at%2015.31.15@2x.png)
![CleanShot 2025-07-21 at 15.31.32@2x.png](CleanShot%202025-07-21%20at%2015.31.32@2x.png)
![CleanShot 2025-07-21 at 15.43.04.png](CleanShot%202025-07-21%20at%2015.43.04.png)
## Задание 5
### Сравнение НТТР/1.1 и НТТР/2 
1. Убедитесь, что веб-сервер поддерживает НТТР/2 (например, проверьте конфигурацию Nginx). 
2. Настройте сервер для работы с НТТР/2.
3. Создайте страницу с несколькими ресурсами (CSS, JS, изображения).
4. Выполните запросы с использованием инструментов curl или браузерных DevTools, чтобы изучить разницу между НТТР/1.1 и НТТР/2.

Конечный результат: Должны быть заметны различия в скорости обработки и загрузки ресурсов между НТТР/1.1 и НТТР/2.

### **1. Проверка поддержки HTTP/2 в Nginx**
#### **1.1. Убедимся, что Nginx собран с поддержкой HTTP/2**
```
nginx -V 2>&1 | grep http_v2_module
```
Если вывод содержит `--with-http_v2_module`, значит, HTTP/2 поддерживается.
#### **1.2. Проверим текущую версию HTTP в Nginx**
Откроем конфиг:
```
sudo nano /etc/nginx/sites-available/default
```
Ищем блок `server`:
```
listen 443 ssl;  # Только HTTP/1.1
listen 443 ssl http2;  # HTTP/2 включён
```
Если `http2` нет, добавим его.

---
### **2. Настройка Nginx для HTTP/2**

#### **2.1. Редактируем конфиг Nginx**
```
sudo nano /etc/nginx/sites-available/default
```
**Обновляем блок `server`:**
```
server {
    listen 443 ssl http2;  # Включаем HTTP/2
    server_name localhost;

    ssl_certificate /etc/nginx/ssl/certificate.crt;
    ssl_certificate_key /etc/nginx/ssl/private.key;

    root /var/www/html;
    index index.html;

    location / {
        try_files $uri $uri/ =404;
    }
}
```
> 🔥 **Важно:** HTTP/2 работает **только с HTTPS** (не поддерживает HTTP).
#### **2.2. Перезапускаем Nginx**
```
sudo nginx -t && sudo systemctl restart nginx
```
#### **2.3. Проверяем, что HTTP/2 работает**
```
curl -I --http2 https://localhost
```
**Ожидаемый вывод:**
```
HTTP/2 200 
server: nginx/...
date: ...
...
```
Если видим `HTTP/2` — значит, всё настроено правильно.

---
### **3. Создание тестовой страницы с несколькими ресурсами**
#### **3.1. Создаём `index.html`**
```
sudo nano /var/www/html/index.html
```
**Добавляем:**
```
<!DOCTYPE html>
<html>
<head>
    <title>HTTP/2 vs HTTP/1.1 Test</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
</head>
<body>
    <h1>HTTP/2 vs HTTP/1.1</h1>
    <img src="image1.jpg" alt="Image 1">
    <img src="image2.jpg" alt="Image 2">
    <img src="image3.jpg" alt="Image 3">
</body>
</html>
```
#### **3.2. Создаём CSS и JS файлы**
```
echo "body { background: #f0f0f0; }" | sudo tee /var/www/html/style.css
echo "console.log('Hello HTTP/2!');" | sudo tee /var/www/html/script.js
```
#### **3.3. Добавляем тестовые изображения**
```
sudo wget https://via.placeholder.com/800x600 -O /var/www/html/image1.jpg
sudo wget https://via.placeholder.com/800x600/ff0000 -O /var/www/html/image2.jpg
sudo wget https://via.placeholder.com/800x600/00ff00 -O /var/www/html/image3.jpg
```
---
### **4. Сравнение HTTP/1.1 и HTTP/2**
#### **4.1. Проверка через `curl`**
#### **HTTP/1.1 (без HTTP/2)**
```
curl -I --http1.1 https://localhost
```
**Вывод:**
```
HTTP/1.1 200 OK
...
```
> ⏳ Запросы выполняются последовательно.
#### **HTTP/2 (мультиплексирование)**
```
curl -I --http2 https://localhost
```
**Вывод:**
```
HTTP/2 200 
...
```
> 🚀 Запросы обрабатываются параллельно.

---
#### **4.2. Проверка в браузере (Chrome DevTools)**
1. Открываем `https://localhost` (примите самоподписанный сертификат).
2. **F12 → Вкладка "Network"**.
3. Обновите страницу (`Ctrl+F5`).
##### **HTTP/1.1**
- Запросы выполняются **последовательно**.
- Много времени тратится на ожидание (`Queueing`).
##### **HTTP/2**
- Запросы выполняются **параллельно**.
- Время загрузки меньше благодаря **мультиплексированию**.

http1.1
![CleanShot 2025-07-21 at 16.40.21.png](CleanShot%202025-07-21%20at%2016.40.21.png)
http2
![CleanShot 2025-07-21 at 16.41.20.png](CleanShot%202025-07-21%20at%2016.41.20.png)


